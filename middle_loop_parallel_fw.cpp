#include<bits/stdc++.h>
#include<omp.h>

using namespace std;

int dist[4096][4096];
int n;
int a,b,c,i,j,k;
int arr[6]={1,2,3,4,8,16};
int main()
{
    //set start size of input and end size of input. Please be sure that testcases of set sizes are available in testcase folder.
    int start_size = 128;
    int end_size = 2048;

    string name_csv = "Result_middleloop.csv";
    fstream csvv;
    csvv.open(name_csv,fstream::out);
    csvv << "Format : Size, Threads, Duration(ms), Speedup, Efficiency\n\n";

    int size = start_size;
    for(;size <= end_size;size *= 2)
    {
        //number of times testcase to be executed
        int num = 7;

        string s = "./testcase/";
        int x = size;
        string mp;
        while(x > 0)
        {
            mp += (char)(x%10 + '0');
            x = x/10;
        }
        reverse(mp.begin(),mp.end());
        s += mp;
        string t = ".txt";
        double base_duration;
        double speed_up;

        for(int th = 0;th <= 5;th++)
        {
            int thds=arr[th];
            vector<double> pk;
            for(int yy = 0;yy < num;yy++)
            {
                int yyy = yy%7;
                int intinf = 1e4;

                string nam;
                string nam1;

                nam += s;
                nam += "/input";
                nam += (char)(yyy/10 + '0');
                nam += (char)(yyy%10 + '0');
                nam += t;

                nam1 += s;
                nam1 += "/output";
                nam1 += (char)(yyy/10 + '0');
                nam1 += (char)(yyy%10 + '0');
                nam1 += t;

                fstream fin,fout;
                fin.open(nam);
                fout.open(nam1);

                //Input
                fin >> n;
                for(int i = 0;i<n;i++)
                    for(int j = 0;j<n;j++)
                        fin >> dist[i][j];

                //Core code
                double t1 = omp_get_wtime();
                for(int k = 0;k<n;k++)
                {
                    #pragma omp parallel for num_threads(thds) schedule(auto)
                    for(int i = 0;i<n;i++)
                    {
                        #pragma omp unroll
                        #pragma omp simd
                        for(int j = 0;j<n;j++)
                        {
                            dist[i][j] = min(dist[i][j],dist[i][k] + dist[k][j]);
                        }
                    }
                }
                double t2 = omp_get_wtime();
                double duration = t2 - t1;
                pk.push_back(duration*1000);

                //validation
                int x;
                for(int i = 0;i<n;i++)
                {
                    for(int j = 0;j<n;j++)
                    {
                        fout >> x;
                        if(dist[i][j] != x)
                        {
                            // if a testcase don't generate output as generated by serial code print 'FAILED' and return
                            cout << "FAILED " << duration <<" ms"<< '\n';
                            return 0;
                        }
                    }
                }

                fin.close();
                fout.close();
            }
            if(thds == 1)
            {
                sort(pk.begin(),pk.end());
                base_duration = pk[num/2];
                csvv << size << "," << thds << "," << pk[num/2] << '\n';
            }
            else
            {
                sort(pk.begin(),pk.end());
                speed_up = base_duration/pk[num/2];
                csvv << size << "," << thds << "," << pk[num/2] << "," << speed_up << "," << speed_up/thds << '\n';
            }
        }
        cout << size << "\n";
        csvv << '\n';
    }

    return 0;
}
